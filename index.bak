<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AWP Analyzer Pro ‚Äî v3.2</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
:root {
  --bg:#f7faff; --fg:#102030; --acc:#007bff; --muted:#708090;
  --card:#fff; --border:#d6dbe2; --orange:#ff8c00; --blue:#007bff;
}
/* Temi */
body.theme-bianco  {--bg:#fff;--fg:#111;--acc:#007bff;}
body.theme-azzurro {--bg:#e9f3ff;--fg:#001830;--acc:#007bff;}
body.theme-arancio {--bg:#fff7ef;--fg:#352200;--acc:#ff8c00;}
body.theme-windows {
  --bg:#c0c0c0;--fg:#000;--card:#dcdcdc;--border:#808080;--acc:#000080;
  font-family:"MS Sans Serif",Tahoma,sans-serif;
}

/* Layout base */
body{margin:0;background:var(--bg);color:var(--fg);
  font-family:Inter,system-ui,sans-serif;
  transition:background .3s,color .3s;}
header{display:flex;justify-content:space-between;align-items:center;
  padding:12px 20px;border-bottom:2px solid var(--border);
  background:linear-gradient(to bottom,var(--card),var(--bg));position:relative;}
h1{font-size:20px;margin:0;color:var(--acc);}main{padding:20px;}

/* Login */
#loginScreen{position:fixed;inset:0;display:flex;flex-direction:column;
  align-items:center;justify-content:center;background:var(--bg);}
#loginBox{background:var(--card);border:1px solid var(--border);padding:30px;
  border-radius:10px;box-shadow:0 8px 25px rgba(0,0,0,.1);width:300px;text-align:center;}
input[type=text],input[type=password]{width:100%;padding:10px;margin:8px 0;
  border:1px solid var(--border);border-radius:5px;background:var(--bg);color:var(--fg);}
button{cursor:pointer;border:none;border-radius:6px;padding:10px 18px;
  font-weight:600;color:#fff;background:var(--acc);transition:.2s;}
button:hover{opacity:.9;}
small.version{display:block;margin-top:15px;color:var(--muted);}
#loginError{color:red;margin-top:8px;}

/* Caricamento */
#progressBarContainer{position:fixed;bottom:0;left:0;right:0;height:6px;background:#ddd;}
#progressBar{height:100%;width:0%;background:var(--acc);transition:width .3s;}

/* Dashboard */
#dashboard{display:none;}
.card{background:var(--card);border:1px solid var(--border);border-radius:10px;
  padding:15px;margin-bottom:15px;box-shadow:0 3px 8px rgba(0,0,0,.05);}
.theme-windows .card{border:2px outset #fff;box-shadow:none;}
footer{text-align:center;padding:10px;font-size:12px;color:var(--muted);}
.fadeIn{animation:fadeIn .5s ease-in;}@keyframes fadeIn{from{opacity:0;}to{opacity:1;}}

/* Menu utente */
#userMenu{position:absolute;right:20px;top:50px;background:var(--card);
  border:1px solid var(--border);border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.15);
  display:none;flex-direction:column;min-width:220px;z-index:50;}
#userMenu div{padding:10px;cursor:pointer;}
#userMenu div:hover{background:var(--acc);color:#fff;}
#userMenu input[type=number]{width:80px;padding:5px;margin-left:6px;}
</style>
</head>
<body class="theme-azzurro">

<!-- LOGIN -->
<div id="loginScreen">
  <div id="loginBox" class="fadeIn">
    <h1>AWP Analyzer Pro</h1>
    <input id="username" type="text" placeholder="Utente">
    <input id="password" type="password" placeholder="PIN">
    <button id="btnLogin">Accedi</button>
    <small class="version">Versione 3.2 ‚Äî Build 2025.11</small>
    <div style="margin-top:10px">
      <select id="themeSelect">
        <option value="azzurro" selected>Azzurro</option>
        <option value="bianco">Bianco</option>
        <option value="arancio">Arancio</option>
        <option value="windows">Windows 95</option>
      </select>
    </div>
    <div id="loginError"></div>
  </div>
</div>

<!-- DASHBOARD -->
<div id="dashboard">
  <header>
    <h1>AWP Analyzer Pro ‚Äî Dashboard</h1>
    <div id="userInfo" style="cursor:pointer;"></div>
    <div id="userMenu" class="fadeIn">
      <div><b>‚öôÔ∏è Impostazioni Utente</b></div>
      <div>
        ‚è± Timeout login (ore): 
        <input type="number" id="timeoutInput" min="1" max="168">
      </div>
      <div>
        üé® Tema:
        <select id="themeSelectMenu">
          <option value="azzurro">Azzurro</option>
          <option value="bianco">Bianco</option>
          <option value="arancio">Arancio</option>
          <option value="windows">Windows 95</option>
        </select>
      </div>
      <div id="logoutBtn" style="color:#d00;font-weight:600;">üö™ Logout</div>
    </div>
  </header>

  <main>
    <div class="card">
      <h2>Stato caricamento dati</h2>
      <div id="loadStatus">In attesa dei file...</div>
    </div>

    <div class="card">
      <h2>Grafico generale (arriva nel BLOCCO 3)</h2>
      <canvas id="mainChart" width="900" height="320"></canvas>
    </div>
  </main>

  <footer>AWP Analyzer Pro v3.2 ‚Äî ¬© 2025 Stephan Winckler</footer>
</div>

<div id="progressBarContainer"><div id="progressBar"></div></div>

<script>
/* === LOGIN da Dati/users.json === */
async function doLogin(){
  const u=username.value.trim().toLowerCase();
  const pin=password.value.trim();
  try{
    const res=await fetch('Dati/users.json',{cache:'no-store'});
    if(!res.ok)throw new Error(`Impossibile leggere Dati/users.json (HTTP ${res.status})`);
    const users=await res.json();
    const user=users.find(x=>x.user.toLowerCase()===u&&x.pin===pin);
    if(!user){loginError.textContent="Credenziali non valide";return;}
    if(user.expires){
      const exp=new Date(user.expires);
      if(exp<new Date()){loginError.textContent="Abbonamento scaduto: "+user.expires;return;}
    }
    localStorage.setItem('awp_user',user.user);
    localStorage.setItem('awp_level',user.level);
    localStorage.setItem('awp_lastLogin',Date.now().toString());
    startApp(user.user,user.level);
  }catch(err){loginError.textContent="Errore: "+err.message;}
}
btnLogin.onclick=doLogin;

/* === Gestione sessione e logout === */
function startApp(u,level="Base"){
  loginScreen.style.display='none';
  dashboard.style.display='block';
  userInfo.textContent=`${u} (${level})`;
  timeoutInput.value=getSessionHours();
  themeSelectMenu.value=getTheme();
  loadManifestAndFiles();
}

function logout(){
  localStorage.removeItem('awp_user');
  localStorage.removeItem('awp_level');
  localStorage.removeItem('awp_lastLogin');
  loginScreen.style.display='flex';
  dashboard.style.display='none';
  username.value='';password.value='';
}

/* === Menu utente === */
userInfo.onclick=()=>{
  userMenu.style.display=(userMenu.style.display==='flex')?'none':'flex';
};
logoutBtn.onclick=logout;
document.addEventListener('click',e=>{
  if(!userMenu.contains(e.target)&&e.target!==userInfo)userMenu.style.display='none';
});

/* Timeout personalizzabile */
timeoutInput.onchange=()=>{
  const hrs=Math.max(1,Math.min(168,timeoutInput.value));
  localStorage.setItem('awp_sessionHours',hrs);
};

/* Tema nel menu */
themeSelectMenu.onchange=e=>{
  setTheme(e.target.value);
  localStorage.setItem('awp_theme',e.target.value);
};
function setTheme(th){
  document.body.className='theme-'+th;
}
function getTheme(){
  return localStorage.getItem('awp_theme')||'azzurro';
}
setTheme(getTheme());

/* Gestione sessione automatica */
function getSessionHours(){
  return parseInt(localStorage.getItem('awp_sessionHours')||'24');
}
const lastUser=localStorage.getItem('awp_user');
const lastLogin=parseInt(localStorage.getItem('awp_lastLogin')||'0');
const now=Date.now();
const limit=getSessionHours()*60*60*1000;
if(lastUser&&(now-lastLogin<limit)){
  startApp(lastUser,localStorage.getItem('awp_level')||'Base');
}else{
  logout();
}

/* === Barra di progresso === */
function setProgress(v){progressBar.style.width=v+"%";}

/* === Caricamento sinottici === */
async function loadManifestAndFiles(){
  const div=document.getElementById('loadStatus');
  setProgress(0);
  try{
    const res=await fetch('Dati/manifest.json',{cache:'no-store'});
    if(!res.ok)throw new Error("Manifest non trovato o accesso negato");
    const manifest=await res.json();
    const files=Array.isArray(manifest)?manifest:(manifest.sinottici||[]);
    if(!files.length)throw new Error("Nessun file trovato nel manifest");
    let done=0,total=files.length,all=[];
    for(const f of files){
      div.innerHTML=`Carico <b>${f}</b> (${done+1}/${total})...`;
      const part=await readXLS(`Dati/${f}`);
      all.push(...part);done++;
      setProgress(Math.round(done/total*100));
      await new Promise(r=>setTimeout(r,50));
    }
    div.innerHTML=`Caricate ${all.length} righe da ${total} file ‚úî`;
  }catch(e){div.innerHTML="Errore: "+e.message;}
}

/* === Lettura Excel === */
async function readXLS(url){
  const res=await fetch(url);
  if(!res.ok)throw new Error("File mancante: "+url);
  const buf=await res.arrayBuffer();
  const wb=XLSX.read(buf,{type:'array'});
  return XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]],{defval:'',raw:false});
}
  /* === BLOCCO 2 ‚Äî Analisi e Previsioni Slot === */

/**
 * Dopo il caricamento di tutti i file, viene chiamata questa funzione.
 * Riceve un array con tutte le righe aggregate dai sinottici.
 */
async function analizzaDatiSlot(allData) {
  const areaAnalisi = document.createElement('div');
  areaAnalisi.className = 'card';
  areaAnalisi.innerHTML = "<h2>Analisi Predittiva Slot</h2><div id='resultGrid'></div>";
  document.querySelector('main').appendChild(areaAnalisi);

  const grid = document.getElementById('resultGrid');
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = 'repeat(auto-fit,minmax(240px,1fr))';
  grid.style.gap = '10px';

  // Raggruppa per N¬∞ macchina o nome
  const macchine = {};
  for (const r of allData) {
    const id = r["N¬∞"] || r["MATRICOLA"] || r["MACHINE"] || "Sconosciuta";
    if (!macchine[id]) macchine[id] = [];
    macchine[id].push(r);
  }

  // Calcola metriche per ciascuna macchina
  for (const id of Object.keys(macchine)) {
    const rows = macchine[id];
    const numerici = rows.map(r => ({
      in: parseFloat(r.CNTTOTIN || r.IN || 0),
      out: parseFloat(r.CNTTOTOUT || r.OUT || 0)
    })).filter(x => x.in > 0);

    if (numerici.length < 2) continue;

    const IN = numerici.map(x => x.in);
    const OUT = numerici.map(x => x.out);
    const diff = numerici.map((x, i) => x.in - x.out);
    const totaleIn = IN[IN.length - 1] - IN[0];
    const totaleOut = OUT[OUT.length - 1] - OUT[0];
    const payout = totaleOut / (totaleIn || 1) * 100;
    const varianza = Math.sqrt(diff.map(x => (x - (totaleIn - totaleOut) / diff.length) ** 2)
                                .reduce((a, b) => a + b, 0) / diff.length);
    const trend = diff[diff.length - 1] - diff[0];

    // Valutazione predittiva
    let stato = '';
    let colore = '';
    let prob = 0;
    if (payout < 60 && trend > 0) { stato = 'üí∞ Alta probabilit√† di pagamento'; colore = '#00a000'; prob = 0.9; }
    else if (payout < 80) { stato = 'üü° Potenziale medio'; colore = '#ffaa00'; prob = 0.6; }
    else if (payout < 100) { stato = 'üü† Paga poco probabile'; colore = '#cc6600'; prob = 0.3; }
    else { stato = 'üî¥ Ciclo scarico o appena pagato'; colore = '#cc0000'; prob = 0.1; }

    // Crea box visivo
    const box = document.createElement('div');
    box.style.border = `2px solid ${colore}`;
    box.style.borderRadius = '8px';
    box.style.padding = '10px';
    box.style.background = 'var(--card)';
    box.innerHTML = `
      <b>${id}</b><br>
      Payout medio: ${payout.toFixed(1)}%<br>
      Variazione ciclo: ${trend.toFixed(0)} crediti<br>
      <b style="color:${colore}">${stato}</b>
      <canvas id="chart_${id}" width="200" height="80"></canvas>
    `;
    grid.appendChild(box);

    // Disegno grafico rapido
    const ctx = box.querySelector('canvas').getContext('2d');
    ctx.lineWidth = 2;

    // Linea verde IN
    ctx.strokeStyle = 'green';
    ctx.beginPath();
    for (let i = 0; i < IN.length; i++) {
      const x = (i / (IN.length - 1)) * 200;
      const y = 80 - (IN[i] - IN[0]) / (IN[IN.length - 1] - IN[0] || 1) * 80;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Linea blu OUT
    ctx.strokeStyle = 'blue';
    ctx.beginPath();
    for (let i = 0; i < OUT.length; i++) {
      const x = (i / (OUT.length - 1)) * 200;
      const y = 80 - (OUT[i] - OUT[0]) / (OUT[OUT.length - 1] - OUT[0] || 1) * 80;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Previsione (linee tratteggiate)
    const previsioni = 10;
    const lastIn = IN[IN.length - 1];
    const lastOut = OUT[OUT.length - 1];
    const deltaIn = (IN[IN.length - 1] - IN[IN.length - 5]) / 5;
    const deltaOut = (OUT[OUT.length - 1] - OUT[OUT.length - 5]) / 5;

    ctx.setLineDash([4, 3]);
    ctx.strokeStyle = 'red';
    ctx.beginPath();
    ctx.moveTo(200, 80 - (IN[IN.length - 1] - IN[0]) / (IN[IN.length - 1] - IN[0] || 1) * 80);
    ctx.lineTo(200 + 20, 80 - ((lastIn + deltaIn * previsioni) - IN[0]) / (IN[IN.length - 1] - IN[0] || 1) * 80);
    ctx.stroke();

    ctx.strokeStyle = 'gold';
    ctx.beginPath();
    ctx.moveTo(200, 80 - (OUT[OUT.length - 1] - OUT[0]) / (OUT[OUT.length - 1] - OUT[0] || 1) * 80);
    ctx.lineTo(200 + 20, 80 - ((lastOut + deltaOut * previsioni) - OUT[0]) / (OUT[OUT.length - 1] - OUT[0] || 1) * 80);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  areaAnalisi.scrollIntoView({ behavior: 'smooth' });
}

/* Integra il motore al termine del caricamento */
const oldLoad = loadManifestAndFiles;
loadManifestAndFiles = async function () {
  const div = document.getElementById('loadStatus');
  setProgress(0);
  try {
    const res = await fetch('Dati/manifest.json', { cache: 'no-store' });
    if (!res.ok) throw new Error("Manifest non trovato o accesso negato");
    const manifest = await res.json();
    const files = Array.isArray(manifest) ? manifest : (manifest.sinottici || []);
    if (!files.length) throw new Error("Nessun file trovato nel manifest");
    let done = 0, total = files.length, all = [];
    for (const f of files) {
      div.innerHTML = `Carico <b>${f}</b> (${done + 1}/${total})...`;
      const part = await readXLS(`Dati/${f}`);
      all.push(...part); done++;
      setProgress(Math.round(done / total * 100));
      await new Promise(r => setTimeout(r, 50));
    }
    div.innerHTML = `Caricate ${all.length} righe da ${total} file ‚úî`;
    // Avvia l‚Äôanalisi
    analizzaDatiSlot(all);
  } catch (e) {
    div.innerHTML = "Errore: " + e.message;
  }
};
  /* === BLOCCO 3 ‚Äî Grafico Avanzato & Filtri === */

// Carica Chart.js
const chartScript = document.createElement("script");
chartScript.src = "https://cdn.jsdelivr.net/npm/chart.js";
document.head.appendChild(chartScript);

chartScript.onload = () => {
  console.log("Chart.js caricato ‚úî");
};

// Contenitore principale
const graficoCard = document.createElement("div");
graficoCard.className = "card";
graficoCard.innerHTML = `
  <h2>üìà Analisi Temporale e Previsioni</h2>
  <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:10px;">
    <select id="slotSelect" style="padding:6px;border:1px solid var(--border);border-radius:6px;">
      <option value="all">Tutte le macchine</option>
    </select>
    <div style="flex:1"></div>
    <button class="periodBtn" data-p="7">Settimana</button>
    <button class="periodBtn" data-p="30">Mese</button>
    <button class="periodBtn" data-p="365">Anno</button>
    <button class="periodBtn" data-p="all">Tutto</button>
    <button class="periodBtn" data-p="forecast">Previsioni</button>
  </div>
  <canvas id="graficoGenerale" height="350"></canvas>
`;
document.querySelector("main").appendChild(graficoCard);

// Variabili globali
let chart;
let currentData = [];
let slotList = [];

// Ricostruisci i dati aggregati per grafico grande
async function preparaDatiPerGrafico(allData) {
  // Ricava colonna tempo
  const groupByDay = {};
  for (const r of allData) {
    const dateRaw = r["DATA LETTURA"] || r["DATA"] || r["DATE"] || "";
    const d = new Date(dateRaw);
    if (isNaN(d)) continue;
    const key = d.toISOString().substring(0, 10);
    const inVal = parseFloat(r.CNTTOTIN || r.IN || 0);
    const outVal = parseFloat(r.CNTTOTOUT || r.OUT || 0);
    if (!groupByDay[key]) groupByDay[key] = { in: 0, out: 0 };
    groupByDay[key].in += inVal;
    groupByDay[key].out += outVal;
  }

  const points = Object.keys(groupByDay)
    .sort()
    .map(k => ({
      date: k,
      in: groupByDay[k].in,
      out: groupByDay[k].out
    }));

  currentData = points;
  slotList = [...new Set(allData.map(r => r["N¬∞"] || r["MATRICOLA"] || "Sconosciuta"))];
  aggiornaSelectSlot();
  disegnaGrafico("all", "all");
}

// Aggiorna menu a tendina con macchine
function aggiornaSelectSlot() {
  const sel = document.getElementById("slotSelect");
  slotList.forEach(s => {
    const opt = document.createElement("option");
    opt.value = s;
    opt.textContent = s;
    sel.appendChild(opt);
  });
  sel.onchange = () => disegnaGrafico(sel.value, "all");
}

// Funzione per disegnare/aggiornare grafico
function disegnaGrafico(slot, periodo) {
  if (!window.Chart || !currentData.length) return;
  const ctx = document.getElementById("graficoGenerale").getContext("2d");

  // Filtro periodo
  let dati = [...currentData];
  if (periodo !== "all" && periodo !== "forecast") {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - parseInt(periodo));
    dati = dati.filter(p => new Date(p.date) >= cutoff);
  }

  const labels = dati.map(p => p.date);
  const inData = dati.map(p => p.in);
  const outData = dati.map(p => p.out);

  // Calcolo forecast base (lineare)
  const steps = 10;
  const lastIn = inData[inData.length - 1];
  const lastOut = outData[outData.length - 1];
  const deltaIn = (lastIn - inData[inData.length - 5]) / 5;
  const deltaOut = (lastOut - outData[outData.length - 5]) / 5;
  const forecastLabels = [];
  const forecastIn = [];
  const forecastOut = [];

  for (let i = 1; i <= steps; i++) {
    const future = new Date(labels[labels.length - 1]);
    future.setDate(future.getDate() + i);
    forecastLabels.push(future.toISOString().substring(0, 10));
    forecastIn.push(lastIn + deltaIn * i);
    forecastOut.push(lastOut + deltaOut * i);
  }

  const datasets = [
    {
      label: "IN",
      data: inData,
      borderColor: "green",
      fill: false,
      tension: 0.1
    },
    {
      label: "OUT",
      data: outData,
      borderColor: "blue",
      fill: false,
      tension: 0.1
    }
  ];

  if (periodo === "forecast") {
    datasets.push({
      label: "Forecast IN",
      data: forecastIn,
      borderColor: "red",
      borderDash: [4, 3],
      fill: false
    });
    datasets.push({
      label: "Forecast OUT",
      data: forecastOut,
      borderColor: "gold",
      borderDash: [4, 3],
      fill: false
    });
  }

  if (chart) chart.destroy();
  chart = new Chart(ctx, {
    type: "line",
    data: { labels: [...labels, ...(periodo === "forecast" ? forecastLabels : [])], datasets },
    options: {
      responsive: true,
      interaction: { mode: "index", intersect: false },
      plugins: {
        legend: { labels: { color: "var(--fg)" } },
        title: { display: false }
      },
      scales: {
        x: { ticks: { color: "var(--fg)" } },
        y: { ticks: { color: "var(--fg)" }, beginAtZero: true }
      }
    }
  });
}

// Collega bottoni periodo
document.querySelectorAll(".periodBtn").forEach(btn => {
  btn.onclick = () => {
    const p = btn.dataset.p;
    const slot = document.getElementById("slotSelect").value;
    disegnaGrafico(slot, p);
  };
});

// Integra con BLOCCO 2
const oldAnalizza = analizzaDatiSlot;
analizzaDatiSlot = async function (allData) {
  await oldAnalizza(allData);
  preparaDatiPerGrafico(allData);
};
  /* === BLOCCO 4 ‚Äî Report & Filtri Intelligenti === */

function creaSezioneReport() {
  const card = document.createElement("div");
  card.className = "card";
  card.innerHTML = `
    <h2>üìä Report & Filtri Intelligenti</h2>
    <div style="display:flex;flex-wrap:wrap;gap:10px;margin-bottom:10px;">
      <input id="searchInput" type="text" placeholder="Cerca slot per nome o matricola"
        style="flex:2;padding:8px;border:1px solid var(--border);border-radius:6px;">
      <label>Payout min % <input id="payoutMin" type="number" value="0"
        style="width:70px;margin-left:5px;padding:5px;"></label>
      <label>max % <input id="payoutMax" type="number" value="200"
        style="width:70px;margin-left:5px;padding:5px;"></label>
      <button id="applyFilter" style="background:var(--acc);color:#fff;border:none;
        border-radius:6px;padding:8px 14px;cursor:pointer;">Filtra</button>
      <button id="exportCSV" style="background:var(--orange);color:#fff;border:none;
        border-radius:6px;padding:8px 14px;cursor:pointer;">Esporta CSV</button>
    </div>
    <div id="reportSummary"
      style="font-weight:600;margin-bottom:6px;color:var(--muted);"></div>
    <div id="reportTable"
      style="overflow-x:auto;max-height:400px;border-top:1px solid var(--border);"></div>
  `;
  document.querySelector("main").appendChild(card);
}

let analisiGlobale = [];

/* Popola la tabella riepilogativa */
function aggiornaReport(lista) {
  const tableDiv = document.getElementById("reportTable");
  if (!lista.length) {
    tableDiv.innerHTML = "<i>Nessuna slot corrispondente ai criteri.</i>";
    return;
  }

  const hot = lista.filter(x => x.status.includes("Alta")).length;
  const mid = lista.filter(x => x.status.includes("medio")).length;
  const cold = lista.filter(x => x.status.includes("poco") || x.status.includes("scarico")).length;

  document.getElementById("reportSummary").textContent =
    `üî• Calde: ${hot} | üü° Medie: ${mid} | ‚ùÑÔ∏è Fredde: ${cold} | Totale: ${lista.length}`;

  let html = `
    <table style="width:100%;border-collapse:collapse;">
      <thead style="background:var(--bg);position:sticky;top:0;">
        <tr>
          <th style="text-align:left;padding:6px;">Slot</th>
          <th>Payout %</th>
          <th>Trend Crediti</th>
          <th>Probabilit√†</th>
          <th>Stato</th>
        </tr>
      </thead><tbody>`;
  lista.forEach(x => {
    html += `
      <tr>
        <td style="padding:6px;">${x.id}</td>
        <td style="text-align:center;">${x.payout.toFixed(1)}</td>
        <td style="text-align:center;">${x.trend.toFixed(0)}</td>
        <td style="text-align:center;">${(x.prob * 100).toFixed(0)}%</td>
        <td style="text-align:center;">${x.status}</td>
      </tr>`;
  });
  html += "</tbody></table>";
  tableDiv.innerHTML = html;
}

/* Applica i filtri e aggiorna */
function applicaFiltri() {
  const q = document.getElementById("searchInput").value.toLowerCase();
  const min = parseFloat(document.getElementById("payoutMin").value || 0);
  const max = parseFloat(document.getElementById("payoutMax").value || 200);
  const filtrati = analisiGlobale.filter(
    x =>
      (!q || x.id.toLowerCase().includes(q)) &&
      x.payout >= min && x.payout <= max
  );
  aggiornaReport(filtrati);
}

/* Esporta CSV */
function esportaCSV() {
  if (!analisiGlobale.length) return;
  let csv = "Slot,Payout%,Trend,Probabilit√†,Stato\n";
  analisiGlobale.forEach(x => {
    csv += `${x.id},${x.payout.toFixed(1)},${x.trend.toFixed(0)},${(x.prob*100).toFixed(0)}%,${x.status}\n`;
  });
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "report_awp.csv";
  a.click();
  URL.revokeObjectURL(url);
}

/* Integra con BLOCCO 2 & 3 */
const oldAnalizza2 = analizzaDatiSlot;
analizzaDatiSlot = async function (allData) {
  await oldAnalizza2(allData);
  creaSezioneReport();

  // Ricrea i dati globali sintetici per il report
  const macchine = {};
  for (const r of allData) {
    const id = r["N¬∞"] || r["MATRICOLA"] || "Sconosciuta";
    if (!macchine[id]) macchine[id] = [];
    macchine[id].push(r);
  }

  analisiGlobale = [];
  for (const id of Object.keys(macchine)) {
    const rows = macchine[id];
    const IN = rows.map(x => parseFloat(x.CNTTOTIN || x.IN || 0));
    const OUT = rows.map(x => parseFloat(x.CNTTOTOUT || x.OUT || 0));
    if (IN.length < 2 || OUT.length < 2) continue;

    const payout = ((OUT[OUT.length - 1] - OUT[0]) /
      ((IN[IN.length - 1] - IN[0]) || 1)) * 100;
    const trend = (IN[IN.length - 1] - OUT[OUT.length - 1]) -
                  (IN[0] - OUT[0]);

    let status = "Neutro", prob = 0.5;
    if (payout < 60 && trend > 0) { status = "Alta probabilit√†"; prob = 0.9; }
    else if (payout < 80) { status = "Media"; prob = 0.6; }
    else if (payout < 100) { status = "Bassa"; prob = 0.3; }
    else { status = "Scarico"; prob = 0.1; }

    analisiGlobale.push({ id, payout, trend, prob, status });
  }

  aggiornaReport(analisiGlobale);

  document.getElementById("applyFilter").onclick = applicaFiltri;
  document.getElementById("exportCSV").onclick = esportaCSV;
  document.getElementById("searchInput").oninput = applicaFiltri;
}
  /* === BLOCCO 5 ‚Äî Cronologia & Avvisi Slot Calde === */

// piccolo suono di notifica
const notifySound = new Audio("https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3");
notifySound.volume = 0.25;

// card cronologia
function creaSezioneCronologia() {
  const card = document.createElement("div");
  card.className = "card";
  card.innerHTML = `
    <h2>üïì Cronologia & Avvisi Slot</h2>
    <div style="margin-bottom:10px;">
      <select id="slotHistorySelect" style="padding:6px;border:1px solid var(--border);border-radius:6px;">
        <option value="">Seleziona una macchina‚Ä¶</option>
      </select>
      <button id="refreshHistory" class="pill">Aggiorna</button>
    </div>
    <div id="alertBox" style="margin-bottom:10px;font-weight:700;"></div>
    <canvas id="chartHistory" height="260"></canvas>
    <div id="historyList" style="max-height:240px;overflow:auto;margin-top:8px;
      border-top:1px solid var(--border);font-size:13px;"></div>
  `;
  document.querySelector("main").appendChild(card);
}

let historyChart;
let lastAlerts = {};

// genera mini-report storico
function aggiornaCronologia(allData) {
  const sel = document.getElementById("slotHistorySelect");
  sel.innerHTML = '<option value="">Seleziona una macchina‚Ä¶</option>';
  const unique = [...new Set(allData.map(r => r["N¬∞"] || r["MATRICOLA"] || "Sconosciuta"))];
  unique.forEach(id => {
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = id;
    sel.appendChild(opt);
  });
  sel.onchange = () => mostraCronologia(sel.value, allData);
  document.getElementById("refreshHistory").onclick = () => mostraCronologia(sel.value, allData);
}

// disegna grafico storico singola slot
function mostraCronologia(id, allData) {
  if (!id) return;
  const serie = allData.filter(r => (r["N¬∞"] || r["MATRICOLA"]) === id);
  if (!serie.length) return;

  const ctx = document.getElementById("chartHistory").getContext("2d");
  const date = serie.map(r => new Date(r["DATA LETTURA"] || r["DATA"] || r["DATE"])).sort((a,b)=>a-b);
  const inVals = serie.map(r => parseFloat(r.CNTTOTIN || r.IN || 0));
  const outVals = serie.map(r => parseFloat(r.CNTTOTOUT || r.OUT || 0));

  // forecast lineare 7 giorni
  const steps = 7;
  const deltaIn = (inVals[inVals.length-1]-inVals[inVals.length-5])/5;
  const deltaOut = (outVals[outVals.length-1]-outVals[outVals.length-5])/5;
  const lastIn = inVals[inVals.length-1];
  const lastOut = outVals[outVals.length-1];
  const futureDates=[], fIn=[], fOut=[];
  for(let i=1;i<=steps;i++){
    const f=new Date(date[date.length-1]); f.setDate(f.getDate()+i);
    futureDates.push(f);
    fIn.push(lastIn+deltaIn*i);
    fOut.push(lastOut+deltaOut*i);
  }

  if(historyChart) historyChart.destroy();
  historyChart = new Chart(ctx,{
    type:"line",
    data:{
      labels:[...date.map(d=>d.toISOString().slice(0,10)),...futureDates.map(d=>d.toISOString().slice(0,10))],
      datasets:[
        {label:"IN",data:inVals,borderColor:"green",fill:false,tension:.2},
        {label:"OUT",data:outVals,borderColor:"blue",fill:false,tension:.2},
        {label:"Forecast IN",data:[...Array(inVals.length).fill(null),...fIn],borderColor:"red",borderDash:[4,3],fill:false},
        {label:"Forecast OUT",data:[...Array(outVals.length).fill(null),...fOut],borderColor:"gold",borderDash:[4,3],fill:false}
      ]
    },
    options:{
      plugins:{legend:{labels:{color:"var(--fg)"}}},
      scales:{x:{ticks:{color:"var(--fg)"}},y:{ticks:{color:"var(--fg)"},beginAtZero:true}}
    }
  });

  // cronologia tabellare
  const hist = document.getElementById("historyList");
  let html = "<table style='width:100%;border-collapse:collapse;'><thead><tr><th>Data</th><th>IN</th><th>OUT</th></tr></thead><tbody>";
  for(let i=0;i<date.length;i++){
    html += `<tr><td>${date[i].toISOString().slice(0,10)}</td><td style="text-align:right;">${inVals[i].toFixed(0)}</td>
             <td style="text-align:right;">${outVals[i].toFixed(0)}</td></tr>`;
  }
  html += "</tbody></table>";
  hist.innerHTML = html;

  // sistema di avviso
  const payout = ((outVals[outVals.length-1]-outVals[0]) / ((inVals[inVals.length-1]-inVals[0])||1))*100;
  const delta = (inVals[inVals.length-1]-outVals[outVals.length-1]) - (inVals[0]-outVals[0]);
  const box = document.getElementById("alertBox");
  box.style.padding = "8px"; box.style.borderRadius = "8px"; box.style.textAlign = "center";
  if(payout<60 && delta>0){
    box.style.background="#fef3c7"; box.style.color="#92400e";
    box.textContent = `‚ö† Slot ${id} in fase calda ‚Äì payout ${payout.toFixed(1)}% probabile pagamento entro 48 h`;
    if(!lastAlerts[id]||Date.now()-lastAlerts[id]>7200000){ // 2 ore
      notifySound.play();
      lastAlerts[id]=Date.now();
    }
  }else if(payout>100){
    box.style.background="#e0f2fe"; box.style.color="#1e3a8a";
    box.textContent = `üí§ Slot ${id} scarica ‚Äì nessuna probabilit√† di pagamento prossimo`;
  }else{
    box.style.background="transparent"; box.style.color="var(--muted)";
    box.textContent = `Nessun alert attivo`;
  }
}

// integrazione con motore
const oldAnalizza3 = analizzaDatiSlot;
analizzaDatiSlot = async function(allData){
  await oldAnalizza3(allData);
  creaSezioneCronologia();
  aggiornaCronologia(allData);
};
  /* === BLOCCO 6 ‚Äî Dashboard Live + Notifiche Push === */

let liveData = { hot:0, medium:0, cold:0, empty:0, avgPayout:0, avgTrend:0 };
let lastNotifyTime = 0;
let liveInterval = null;

// Card principale
function creaSezioneLive() {
  const card = document.createElement("div");
  card.className = "card";
  card.id = "liveCard";
  card.innerHTML = `
    <h2>üì° Dashboard Live & Notifiche</h2>
    <div id="liveStats" style="display:flex;flex-wrap:wrap;gap:14px;margin-bottom:12px;">
      <div class="statLive" id="liveHot">üî• Calde: 0</div>
      <div class="statLive" id="liveMid">üü° Medie: 0</div>
      <div class="statLive" id="liveCold">‚ùÑÔ∏è Fredde: 0</div>
      <div class="statLive" id="liveEmpty">üí§ Scariche: 0</div>
      <div class="statLive" id="liveAvg">üìà Payout medio: ‚Äî%</div>
      <div class="statLive" id="liveTrend">üí∂ Trend medio: ‚Äî‚Ç¨</div>
    </div>
    <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;">
      <label>‚è± Aggiornamento ogni</label>
      <select id="refreshTime" style="padding:6px;border:1px solid var(--border);border-radius:6px;">
        <option value="1">1 min</option>
        <option value="2" selected>2 min</option>
        <option value="5">5 min</option>
        <option value="10">10 min</option>
      </select>
      <button id="manualRefresh" class="pill">Aggiorna ora</button>
      <button id="toggleNotify" class="pill">üîî Notifiche ON</button>
    </div>
    <canvas id="chartLive" height="220"></canvas>
  `;
  document.querySelector("main").appendChild(card);
}

/* Richiede permesso notifiche */
async function richiediNotifiche() {
  if (!("Notification" in window)) return false;
  const perm = await Notification.requestPermission();
  return perm === "granted";
}

/* Invia notifica visiva */
function inviaNotifica(titolo, testo) {
  const now = Date.now();
  if (now - lastNotifyTime < 60000) return; // max 1 al minuto
  lastNotifyTime = now;
  new Notification(titolo, { body: testo, icon: "https://cdn-icons-png.flaticon.com/512/741/741407.png" });
  notifySound.play();
}

/* Calcola statistiche globali */
function aggiornaDashboardLive() {
  if (!analisiGlobale?.length) return;
  const hot = analisiGlobale.filter(x=>x.status.includes("Alta")).length;
  const mid = analisiGlobale.filter(x=>x.status.includes("Media")).length;
  const cold = analisiGlobale.filter(x=>x.status.includes("Bassa")).length;
  const empty = analisiGlobale.filter(x=>x.status.includes("Scarico")).length;
  const avgPayout = analisiGlobale.reduce((a,b)=>a+b.payout,0)/analisiGlobale.length;
  const avgTrend = analisiGlobale.reduce((a,b)=>a+b.trend,0)/analisiGlobale.length;

  liveData = { hot, medium:mid, cold, empty, avgPayout, avgTrend };

  document.getElementById("liveHot").textContent = `üî• Calde: ${hot}`;
  document.getElementById("liveMid").textContent = `üü° Medie: ${mid}`;
  document.getElementById("liveCold").textContent = `‚ùÑÔ∏è Fredde: ${cold}`;
  document.getElementById("liveEmpty").textContent = `üí§ Scariche: ${empty}`;
  document.getElementById("liveAvg").textContent = `üìà Payout medio: ${avgPayout.toFixed(1)}%`;
  document.getElementById("liveTrend").textContent = `üí∂ Trend medio: ${avgTrend.toFixed(0)} ‚Ç¨`;

  if (hot >= 3) inviaNotifica("Slot calde rilevate!", `${hot} macchine in fase di pagamento imminente`);

  aggiornaGraficoLive();
}

/* Grafico cumulativo */
let chartLive;
function aggiornaGraficoLive() {
  const ctx = document.getElementById("chartLive").getContext("2d");
  if (chartLive) chartLive.destroy();
  chartLive = new Chart(ctx, {
    type: "bar",
    data: {
      labels: ["Calde", "Medie", "Fredde", "Scariche"],
      datasets: [
        { label: "Numero Slot", data: [liveData.hot, liveData.medium, liveData.cold, liveData.empty],
          backgroundColor: ["#f87171","#facc15","#60a5fa","#9ca3af"] }
      ]
    },
    options: {
      plugins:{legend:{display:false}},
      scales:{
        x:{ticks:{color:"var(--fg)"}},
        y:{ticks:{color:"var(--fg)"},beginAtZero:true}
      }
    }
  });
}

/* Auto-refresh */
function impostaAggiornamento() {
  const mins = parseInt(document.getElementById("refreshTime").value);
  if (liveInterval) clearInterval(liveInterval);
  liveInterval = setInterval(()=>aggiornaDashboardLive(), mins*60000);
}

/* Integrazione nel motore */
const oldAnalizza4 = analizzaDatiSlot;
analizzaDatiSlot = async function(allData){
  await oldAnalizza4(allData);
  creaSezioneLive();
  aggiornaDashboardLive();
  impostaAggiornamento();

  document.getElementById("refreshTime").onchange = impostaAggiornamento;
  document.getElementById("manualRefresh").onclick = aggiornaDashboardLive;

  const toggle = document.getElementById("toggleNotify");
  let notifyOn = true;
  toggle.onclick = async ()=>{
    notifyOn = !notifyOn;
    toggle.textContent = notifyOn ? "üîî Notifiche ON" : "üîï Notifiche OFF";
    if (notifyOn) await richiediNotifiche();
  };
};
  /* === BLOCCO 7 ‚Äî Temi Windows95 + Impostazioni Utente === */

// Stili base per i nuovi temi
const style = document.createElement("style");
style.textContent = `
html[data-theme=azzurro]{
  --bg:#e6f1ff;--fg:#072043;--card:#ffffff;--border:#a9c6ff;
  --acc:#0078d7;--orange:#f59e0b;--muted:#4a6a99;
}
html[data-theme=bianco]{
  --bg:#ffffff;--fg:#222;--card:#f9f9f9;--border:#dcdcdc;
  --acc:#2563eb;--orange:#f59e0b;--muted:#666;
}
html[data-theme=arancio]{
  --bg:#fff8f2;--fg:#201108;--card:#fffaf5;--border:#f2c79d;
  --acc:#f97316;--orange:#d97706;--muted:#885f3a;
}
html[data-theme=win95]{
  --bg:#c3c7cb;--fg:#000;--card:#e3e3e3;--border:#808080;
  --acc:#008080;--orange:#d97706;--muted:#404040;
  font-family:"MS Sans Serif",Tahoma,sans-serif;
}
.win95-btn{border:2px outset #fff;background:#d4d0c8;padding:4px 10px;font-family:inherit;}
.win95-btn:active{border-style:inset;background:#c3c3c3;}
.win95-window{border:2px outset #fff;background:#e3e3e3;padding:8px;}
`;
document.head.appendChild(style);

/* === MENU UTENTE === */
const userMenu = document.createElement("div");
userMenu.id = "userMenu";
userMenu.style.cssText = `
  position:absolute;top:50px;right:20px;display:none;z-index:1000;
  background:var(--card);border:1px solid var(--border);border-radius:8px;
  box-shadow:0 4px 18px rgba(0,0,0,.2);padding:10px;min-width:220px;
`;
userMenu.innerHTML = `
  <h4 style="margin-top:0;">‚öôÔ∏è Impostazioni Utente</h4>
  <label>Timeout Login (ore): <input id="loginTimeout" type="number" min="1" max="72" value="24"
     style="width:70px;"></label><br><br>
  <label>Tema Interfaccia:</label><br>
  <select id="themeSelect" style="width:100%;padding:4px;margin-top:4px;">
    <option value="azzurro">Azzurro</option>
    <option value="bianco">Bianco</option>
    <option value="arancio">Arancio</option>
    <option value="win95">Windows 95</option>
  </select><br><br>
  <label><input type="checkbox" id="soundToggle" checked> Suono notifiche</label><br><br>
  <button id="savePrefs" class="pill" style="width:100%;">üíæ Salva Preferenze</button>
`;
document.body.appendChild(userMenu);

/* Toggle del menu */
const userInfoEl = document.getElementById("userInfo");
if (userInfoEl) {
  userInfoEl.style.cursor = "pointer";
  userInfoEl.onclick = () => {
    userMenu.style.display = userMenu.style.display === "none" ? "block" : "none";
  };
}
document.addEventListener("click", e => {
  if (!userMenu.contains(e.target) && e.target !== userInfoEl) userMenu.style.display = "none";
});

/* Gestione preferenze */
const PREF_KEY = "awp_userPrefs";
let prefs = { timeoutHrs:24, theme:"azzurro", sound:true };
try { prefs = Object.assign(prefs, JSON.parse(localStorage.getItem(PREF_KEY)||"{}")); }catch{}
document.documentElement.setAttribute("data-theme", prefs.theme);
document.getElementById("loginTimeout").value = prefs.timeoutHrs;
document.getElementById("themeSelect").value = prefs.theme;
document.getElementById("soundToggle").checked = prefs.sound;
notifySound.muted = !prefs.sound;

document.getElementById("savePrefs").onclick = ()=>{
  prefs.timeoutHrs = parseInt(document.getElementById("loginTimeout").value)||24;
  prefs.theme = document.getElementById("themeSelect").value;
  prefs.sound = document.getElementById("soundToggle").checked;
  localStorage.setItem(PREF_KEY, JSON.stringify(prefs));
  document.documentElement.setAttribute("data-theme", prefs.theme);
  notifySound.muted = !prefs.sound;
  toast("‚úÖ Preferenze salvate");
};

/* Applica timeout personalizzato al login persistente */
const customDuration = prefs.timeoutHrs * 60 * 60 * 1000;
if (customDuration && customDuration !== SESSION_DURATION) {
  clearInterval(liveInterval);
  console.log(`Sessione personalizzata: ${prefs.timeoutHrs} ore`);
}
 /* === BLOCCO 8 ‚Äî Esportazione Report PDF Professionale === */

// Carica pdf-lib
const pdfLib = document.createElement("script");
pdfLib.src = "https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js";
document.head.appendChild(pdfLib);

// Aggiunge pulsante nella dashboard live
function aggiungiBottonePDF() {
  const card = document.getElementById("liveCard");
  const btn = document.createElement("button");
  btn.className = "pill";
  btn.style.marginTop = "8px";
  btn.textContent = "üìÑ Esporta Report PDF";
  btn.onclick = generaReportPDF;
  card.appendChild(btn);
}

/* Genera il PDF */
async function generaReportPDF() {
  if (!window.PDFLib || !analisiGlobale.length) {
    alert("Analisi non disponibile o libreria PDF non pronta.");
    return;
  }

  const { PDFDocument, StandardFonts, rgb } = PDFLib;
  const pdf = await PDFDocument.create();
  const page = pdf.addPage([595.28, 841.89]); // A4
  const font = await pdf.embedFont(StandardFonts.Helvetica);
  const { width, height } = page.getSize();
  const now = new Date().toLocaleString();

  // colori coerenti col tema
  const theme = document.documentElement.getAttribute("data-theme") || "azzurro";
  const colors = {
    azzurro: rgb(0.02, 0.46, 0.84),
    bianco: rgb(0.2, 0.2, 0.2),
    arancio: rgb(0.97, 0.58, 0.06),
    win95: rgb(0.0, 0.5, 0.5)
  };
  const color = colors[theme] || rgb(0,0,0);

  // header
  page.drawText("AWP ANALYZER PRO ‚Äî REPORT PREVISIONALE", { x: 40, y: height - 60, size: 16, font, color });
  page.drawText(`Generato il ${now}`, { x: 40, y: height - 80, size: 10, font, color: rgb(0.3, 0.3, 0.3) });

  // live summary
  const summaryY = height - 120;
  page.drawText(`üî• Calde: ${liveData.hot}   üü° Medie: ${liveData.medium}   ‚ùÑÔ∏è Fredde: ${liveData.cold}   üí§ Scariche: ${liveData.empty}`, 
                { x: 40, y: summaryY, size: 12, font, color });
  page.drawText(`üìà Payout medio: ${liveData.avgPayout.toFixed(1)}%   üí∂ Trend medio: ${liveData.avgTrend.toFixed(0)} ‚Ç¨`, 
                { x: 40, y: summaryY - 18, size: 12, font, color });

  // tabella slot principali
  const headerY = summaryY - 50;
  page.drawText("MACHINE", { x: 40, y: headerY, size: 10, font, color });
  page.drawText("PAYOUT%", { x: 170, y: headerY, size: 10, font, color });
  page.drawText("TREND", { x: 250, y: headerY, size: 10, font, color });
  page.drawText("PROB%", { x: 330, y: headerY, size: 10, font, color });
  page.drawText("STATO", { x: 410, y: headerY, size: 10, font, color });

  let y = headerY - 14;
  analisiGlobale.slice(0, 30).forEach(slot => {
    page.drawText(slot.id.toString().substring(0, 16), { x: 40, y, size: 9, font, color: rgb(0,0,0) });
    page.drawText(slot.payout.toFixed(1), { x: 170, y, size: 9, font });
    page.drawText(slot.trend.toFixed(0), { x: 250, y, size: 9, font });
    page.drawText((slot.prob*100).toFixed(0)+"%", { x: 330, y, size: 9, font });
    page.drawText(slot.status, { x: 410, y, size: 9, font });
    y -= 12;
    if (y < 60) {
      y = height - 60;
      pdf.addPage();
    }
  });

  // footer
  page.drawText("Generato automaticamente da AWP Analyzer Pro", { x: 40, y: 30, size: 9, font, color: rgb(0.5, 0.5, 0.5) });

  const pdfBytes = await pdf.save();
  const blob = new Blob([pdfBytes], { type: "application/pdf" });
  const url = URL.createObjectURL(blob);
  window.open(url, "_blank");
}

/* Integra nel flusso */
const oldAnalizza5 = analizzaDatiSlot;
analizzaDatiSlot = async function(allData){
  await oldAnalizza5(allData);
  aggiungiBottonePDF();
};
 /* === BLOCCO 9 ‚Äî Modalit√† Offline + PWA === */

// Aggiunge manifest PWA dinamicamente
const manifestData = {
  name: "AWP Analyzer Pro",
  short_name: "AWP Analyzer",
  start_url: ".",
  display: "standalone",
  background_color: "#ffffff",
  theme_color: "#0078d7",
  icons: [
    { src: "https://cdn-icons-png.flaticon.com/512/741/741407.png", sizes: "192x192", type: "image/png" },
    { src: "https://cdn-icons-png.flaticon.com/512/741/741407.png", sizes: "512x512", type: "image/png" }
  ]
};
const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: "application/json" });
const manifestURL = URL.createObjectURL(manifestBlob);
const manifestTag = document.createElement("link");
manifestTag.rel = "manifest";
manifestTag.href = manifestURL;
document.head.appendChild(manifestTag);

// Service Worker per cache offline
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("sw.js").then(() => {
      console.log("üõ∞ Service Worker registrato");
    });
  });
}

// Mostra stato offline
const offlineBanner = document.createElement("div");
offlineBanner.id = "offlineBanner";
offlineBanner.style.cssText = `
  position:fixed;bottom:0;left:0;width:100%;
  background:#facc15;color:#1a1a1a;
  text-align:center;padding:6px;font-weight:600;
  display:none;z-index:9999;
`;
offlineBanner.textContent = "üõ∞ Modalit√† Offline attiva ‚Äì alcune funzioni potrebbero essere limitate";
document.body.appendChild(offlineBanner);

window.addEventListener("online", ()=> offlineBanner.style.display="none");
window.addEventListener("offline", ()=> offlineBanner.style.display="block");

/* Cache automatica dei dati */
async function salvaCacheDati(key, data) {
  try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.warn("Cache non salvata", e); }
}
function caricaCacheDati(key) {
  try { return JSON.parse(localStorage.getItem(key)||"[]"); } catch { return []; }
}

/* Integra nel motore analitico */
const oldAnalizza6 = analizzaDatiSlot;
analizzaDatiSlot = async function(allData){
  await oldAnalizza6(allData);
  salvaCacheDati("awp_lastAnalysis", analisiGlobale);
};

/* Se offline all‚Äôavvio, ricarica dati cache */
if (!navigator.onLine) {
  const cached = caricaCacheDati("awp_lastAnalysis");
  if (cached.length) {
    console.log("üíæ Dati caricati dalla cache locale:", cached.length, "record");
    analisiGlobale = cached;
    setTimeout(()=>{ aggiornaReport(analisiGlobale); aggiornaDashboardLive(); }, 500);
    offlineBanner.style.display = "block";
  }
}
  /* === BLOCCO 10 ‚Äî Algoritmo Predittivo Reale (AI/ML) === */

// Carica TensorFlow.js per il modello predittivo
const tfScript = document.createElement("script");
tfScript.src = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js";
document.head.appendChild(tfScript);

let modelloPredittivo = null;
let datiAddestramento = [];

/* Estrai dati numerici per ogni macchina */
function preparaDataset(allData) {
  const slots = {};
  for (const r of allData) {
    const id = r["N¬∞"] || r["MATRICOLA"] || "Sconosciuta";
    if (!slots[id]) slots[id] = [];
    const inVal = parseFloat(r.CNTTOTIN || r.IN || 0);
    const outVal = parseFloat(r.CNTTOTOUT || r.OUT || 0);
    const payout = outVal > 0 ? (outVal / (inVal || 1)) * 100 : 0;
    slots[id].push({ inVal, outVal, payout });
  }

  const dataset = [];
  for (const id of Object.keys(slots)) {
    const seq = slots[id];
    if (seq.length < 6) continue;
    for (let i = 5; i < seq.length; i++) {
      const prev = seq.slice(i - 5, i);
      const next = seq[i];
      const features = prev.flatMap(p => [p.inVal, p.outVal, p.payout]);
      const label = next.outVal - next.inVal; // utile per stimare payout
      dataset.push({ features, label });
    }
  }
  return dataset;
}

/* Addestra modello */
async function addestraModello(dataset) {
  if (!window.tf || !dataset.length) return null;
  console.log("üß† Addestramento modello predittivo su", dataset.length, "campioni...");

  const xs = tf.tensor2d(dataset.map(d => d.features));
  const ys = tf.tensor2d(dataset.map(d => [d.label]));

  const model = tf.sequential();
  model.add(tf.layers.dense({ inputShape: [dataset[0].features.length], units: 32, activation: "relu" }));
  model.add(tf.layers.dense({ units: 16, activation: "relu" }));
  model.add(tf.layers.dense({ units: 1, activation: "linear" }));

  model.compile({ optimizer: tf.train.adam(0.01), loss: "meanSquaredError" });
  await model.fit(xs, ys, { epochs: 25, batchSize: 32, verbose: 0 });

  const save = await model.save("indexeddb://awp-predict-model");
  console.log("üíæ Modello salvato localmente:", save);
  return model;
}

/* Carica modello esistente */
async function caricaModelloSalvato() {
  try {
    const model = await tf.loadLayersModel("indexeddb://awp-predict-model");
    console.log("‚ö° Modello predittivo caricato da cache");
    return model;
  } catch {
    console.warn("Nessun modello salvato trovato, verr√† creato nuovo.");
    return null;
  }
}

/* Previsione per ogni macchina */
async function previsioniAI(allData) {
  if (!modelloPredittivo) return;

  const perSlot = {};
  const slots = [...new Set(allData.map(r => r["N¬∞"] || r["MATRICOLA"] || "Sconosciuta"))];

  for (const id of slots) {
    const seq = allData.filter(r => (r["N¬∞"] || r["MATRICOLA"]) === id)
                       .slice(-5)
                       .map(r => ({
                         inVal: parseFloat(r.CNTTOTIN || r.IN || 0),
                         outVal: parseFloat(r.CNTTOTOUT || r.OUT || 0),
                         payout: parseFloat(r.CNTTOTOUT || 0) / ((parseFloat(r.CNTTOTIN || 1)) || 1) * 100
                       }));
    if (seq.length < 5) continue;

    const features = seq.flatMap(p => [p.inVal, p.outVal, p.payout]);
    const tensor = tf.tensor2d([features]);
    const prediction = modelloPredittivo.predict(tensor);
    const value = (await prediction.data())[0];
    const prob = Math.min(1, Math.max(0, (value > 0 ? value / 10000 : 0.1)));

    perSlot[id] = { predDelta: value, prob };
  }

  // aggiorna tabella e avvisi
  aggiornaSezionePrevisioni(perSlot);
}

/* Mostra risultati IA */
function aggiornaSezionePrevisioni(previste) {
  const card = document.createElement("div");
  card.className = "card";
  card.innerHTML = `<h2>ü§ñ Previsioni AI / Machine Learning</h2>
    <div id="aiSummary" style="font-weight:600;color:var(--muted);margin-bottom:6px;">
      Il modello analizza le variazioni introdotto/pagato e prevede la probabilit√† di pagamento imminente per ogni macchina.
    </div>
    <table style="width:100%;border-collapse:collapse;">
      <thead><tr><th style="text-align:left;">Slot</th><th>Œî previsto</th><th>Probabilit√†</th><th>Stato</th></tr></thead><tbody id="aiTable"></tbody>
    </table>`;
  document.querySelector("main").appendChild(card);

  const body = card.querySelector("#aiTable");
  Object.entries(previste).forEach(([id, val]) => {
    let stato = "Neutro";
    if (val.prob > 0.8) stato = "üî• Alta probabilit√†";
    else if (val.prob > 0.6) stato = "üü° Media";
    else if (val.prob < 0.3) stato = "‚ùÑÔ∏è Bassa";
    body.innerHTML += `
      <tr><td>${id}</td><td>${val.predDelta.toFixed(0)}</td>
      <td>${(val.prob*100).toFixed(1)}%</td><td>${stato}</td></tr>`;
  });
}

/* Integrazione con flusso principale */
const oldAnalizza7 = analizzaDatiSlot;
analizzaDatiSlot = async function(allData) {
  await oldAnalizza7(allData);
  datiAddestramento = preparaDataset(allData);
  modelloPredittivo = await caricaModelloSalvato();
  if (!modelloPredittivo) modelloPredittivo = await addestraModello(datiAddestramento);
  await previsioniAI(allData);
};
 /* === BLOCCO 11 ‚Äî Mappa Termica Interattiva === */

// Crea la card
function creaSezioneMappa() {
  const card = document.createElement("div");
  card.className = "card";
  card.innerHTML = `
    <h2>üó∫Ô∏è Mappa Termica Slot</h2>
    <p style="color:var(--muted);margin-top:-6px;">
      Ogni punto rappresenta una macchina: colore = probabilit√† di pagamento, dimensione = payout previsto.
    </p>
    <canvas id="heatMapChart" height="380"></canvas>
  `;
  document.querySelector("main").appendChild(card);
}

let heatMapChart;

// Disegna la mappa
function disegnaMappaTermica(previsioni, analisi) {
  if (!window.Chart) return;
  const ctx = document.getElementById("heatMapChart").getContext("2d");
  if (heatMapChart) heatMapChart.destroy();

  // Costruisci dataset combinando AI + analisi
  const dati = [];
  Object.entries(previsioni).forEach(([id, v]) => {
    const ref = analisi.find(a => a.id === id);
    const payout = ref ? ref.payout : 100;
    const trend = ref ? ref.trend : 0;
    const colore =
      v.prob > 0.8 ? "rgba(239,68,68,0.8)" :
      v.prob > 0.6 ? "rgba(250,204,21,0.8)" :
      v.prob > 0.3 ? "rgba(96,165,250,0.8)" :
      "rgba(148,163,184,0.6)";
    dati.push({
      x: payout,
      y: trend,
      r: Math.max(6, Math.min(30, Math.abs(v.predDelta) / 300)),
      backgroundColor: colore,
      borderColor: "rgba(0,0,0,0.2)",
      borderWidth: 1,
      label: id,
      prob: (v.prob * 100).toFixed(0)
    });
  });

  heatMapChart = new Chart(ctx, {
    type: "bubble",
    data: { datasets: [{ label: "Slot", data: dati }] },
    options: {
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx =>
              `${ctx.raw.label} ‚Üí ${ctx.raw.prob}% prob, Payout ${ctx.raw.x.toFixed(1)}%, Trend ${ctx.raw.y.toFixed(0)}`
          }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          title: { display: true, text: "Payout %" },
          ticks: { color: "var(--fg)" },
          grid: { color: "rgba(0,0,0,0.1)" }
        },
        y: {
          title: { display: true, text: "Trend crediti" },
          ticks: { color: "var(--fg)" },
          grid: { color: "rgba(0,0,0,0.1)" }
        }
      }
    }
  });
}

/* Integrazione col motore AI */
const oldAnalizza8 = analizzaDatiSlot;
analizzaDatiSlot = async function (allData) {
  await oldAnalizza8(allData);
  creaSezioneMappa();

  // Ricarica dati AI precedenti se disponibili
  const previsioni = {};
  if (typeof previsioniAI === "function" && modelloPredittivo) {
    const slots = [...new Set(allData.map(r => r["N¬∞"] || r["MATRICOLA"]))];
    for (const id of slots) {
      const seq = allData
        .filter(r => (r["N¬∞"] || r["MATRICOLA"]) === id)
        .slice(-5)
        .map(r => ({
          inVal: parseFloat(r.CNTTOTIN || r.IN || 0),
          outVal: parseFloat(r.CNTTOTOUT || r.OUT || 0),
          payout: parseFloat(r.CNTTOTOUT || 0) /
                   ((parseFloat(r.CNTTOTIN || 1)) || 1) * 100
        }));
      if (seq.length < 5) continue;
      const features = seq.flatMap(p => [p.inVal, p.outVal, p.payout]);
      const t = tf.tensor2d([features]);
      const val = (await modelloPredittivo.predict(t).data())[0];
      const prob = Math.min(1, Math.max(0, (val > 0 ? val / 10000 : 0.1)));
      previsioni[id] = { predDelta: val, prob };
    }
  }

  disegnaMappaTermica(previsioni, analisiGlobale);
};
  /* === BLOCCO 12 ‚Äî Timeline Animata della Mappa Termica === */

function creaSezioneTimeline() {
  const card = document.createElement("div");
  card.className = "card";
  card.innerHTML = `
    <h2>üéûÔ∏è Timeline Evoluzione Slot</h2>
    <p style="color:var(--muted);margin-top:-6px;">
      Riproduci giorno per giorno come sono cambiate le probabilit√† e i payout.
    </p>
    <div style="display:flex;align-items:center;gap:6px;margin-bottom:8px;">
      <button id="tlBack" class="pill">‚è™</button>
      <button id="tlPlay" class="pill">‚ñ∂ Play</button>
      <button id="tlPause" class="pill" disabled>‚è∏ Pausa</button>
      <button id="tlNext" class="pill">‚è©</button>
      <button id="tlReset" class="pill">‚èπ Reset</button>
      <span id="tlDateLabel" style="margin-left:10px;font-weight:600;color:var(--muted);"></span>
    </div>
    <canvas id="timelineChart" height="380"></canvas>
  `;
  document.querySelector("main").appendChild(card);
}

let timelineChart;
let timelineData = [];
let tlIndex = 0;
let tlTimer = null;
let tlPlaying = false;

function preparaTimeline(allData) {
  // Raggruppa per giorno
  const perGiorno = {};
  for (const r of allData) {
    const date = (r["DATA LETTURA"] || r["DATA"] || r["DATE"] || "").split(" ")[0];
    if (!date) continue;
    if (!perGiorno[date]) perGiorno[date] = [];
    const inVal = parseFloat(r.CNTTOTIN || r.IN || 0);
    const outVal = parseFloat(r.CNTTOTOUT || r.OUT || 0);
    const payout = outVal / (inVal || 1) * 100;
    perGiorno[date].push({ id: r["N¬∞"] || r["MATRICOLA"], inVal, outVal, payout });
  }
  timelineData = Object.entries(perGiorno).sort((a,b)=>new Date(a[0])-new Date(b[0]));
  console.log("üéûÔ∏è Timeline caricata:", timelineData.length, "giorni");
}

function disegnaTimelineFrame(index) {
  if (!timelineData.length) return;
  const ctx = document.getElementById("timelineChart").getContext("2d");
  const [giorno, records] = timelineData[index];
  const points = records.map(r=>{
    const delta = r.outVal - r.inVal;
    const prob = Math.max(0, Math.min(1, (delta>0?delta/10000:0.1)));
    const color =
      prob>0.8?"rgba(239,68,68,0.8)":
      prob>0.6?"rgba(250,204,21,0.8)":
      prob>0.3?"rgba(96,165,250,0.8)":
      "rgba(148,163,184,0.6)";
    return {x:r.payout,y:delta,r:Math.max(4,Math.min(25,Math.abs(delta)/300)),backgroundColor:color,label:r.id};
  });

  if (timelineChart) timelineChart.destroy();
  timelineChart = new Chart(ctx,{
    type:"bubble",
    data:{datasets:[{data:points}]},
    options:{
      animation:false,
      plugins:{
        legend:{display:false},
        tooltip:{callbacks:{label:c=>`${c.raw.label} ‚Äî payout ${c.raw.x.toFixed(1)}%`}}
      },
      scales:{
        x:{title:{display:true,text:"Payout %"},ticks:{color:"var(--fg)"}},
        y:{title:{display:true,text:"Œî Crediti"},ticks:{color:"var(--fg)"}}
      }
    }
  });

  document.getElementById("tlDateLabel").textContent = giorno;
}

function controlliTimeline() {
  const play = document.getElementById("tlPlay");
  const pause = document.getElementById("tlPause");
  const next = document.getElementById("tlNext");
  const back = document.getElementById("tlBack");
  const reset = document.getElementById("tlReset");

  play.onclick = ()=>{
    if (tlPlaying) return;
    tlPlaying=true;
    play.disabled=true; pause.disabled=false;
    tlTimer=setInterval(()=>{
      if (tlIndex<timelineData.length-1){ tlIndex++; disegnaTimelineFrame(tlIndex);}
      else{ clearInterval(tlTimer); tlPlaying=false; play.disabled=false; pause.disabled=true;}
    },1200);
  };
  pause.onclick = ()=>{ clearInterval(tlTimer); tlPlaying=false; play.disabled=false; pause.disabled=true; };
  next.onclick = ()=>{ if (tlIndex<timelineData.length-1){tlIndex++; disegnaTimelineFrame(tlIndex);} };
  back.onclick = ()=>{ if (tlIndex>0){tlIndex--; disegnaTimelineFrame(tlIndex);} };
  reset.onclick = ()=>{ tlIndex=0; disegnaTimelineFrame(tlIndex); };
}

/* Integrazione nel flusso */
const oldAnalizza9 = analizzaDatiSlot;
analizzaDatiSlot = async function(allData){
  await oldAnalizza9(allData);
  creaSezioneTimeline();
  preparaTimeline(allData);
  disegnaTimelineFrame(0);
  controlliTimeline();
};
 /* === BLOCCO 13 ‚Äî Sincronizzazione Multi-Tablet LAN === */

// Configurazione: cambia in base alla tua rete locale
const WEBSOCKET_URL = "ws://omen.local:8080"; // puoi anche usare ws://192.168.x.x:8080
let ws;
let isMaster = false;

/* Avvia la connessione */
function avviaSyncSocket() {
  if (!("WebSocket" in window)) return console.warn("WebSocket non supportato");
  try {
    ws = new WebSocket(WEBSOCKET_URL);
    ws.onopen = () => {
      console.log("üîå Connessione WebSocket aperta con il server");
      ws.send(JSON.stringify({ type: "hello", user: localStorage.getItem("awp_user") || "anonimo" }));
    };
    ws.onmessage = (event) => gestisciMessaggio(event.data);
    ws.onclose = () => console.warn("‚ùå WebSocket chiuso. Ritento tra 5s...") || setTimeout(avviaSyncSocket, 5000);
  } catch (e) {
    console.warn("Connessione WebSocket fallita", e);
  }
}

/* Gestione messaggi */
function gestisciMessaggio(msg) {
  let data;
  try { data = JSON.parse(msg); } catch { return; }

  if (data.type === "sync-broadcast" && data.payload) {
    console.log("üì° Ricevuto aggiornamento sincronizzato:", data.payload.info);
    if (data.payload.analisi) {
      analisiGlobale = data.payload.analisi;
      aggiornaReport(analisiGlobale);
      aggiornaDashboardLive();
    }
    if (data.payload.alert) {
      toast(`üîî ${data.payload.alert}`);
    }
  }

  if (data.type === "request-role") {
    // Il primo che risponde diventa master
    if (!isMaster) {
      ws.send(JSON.stringify({ type: "role-confirm", role: "client" }));
    } else {
      ws.send(JSON.stringify({ type: "role-confirm", role: "master" }));
    }
  }
}

/* Invia un broadcast */
function inviaBroadcast(payload) {
  if (!ws || ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "sync-broadcast", payload }));
}

/* Integrazione con motore: il master propaga i risultati */
const oldAnalizza10 = analizzaDatiSlot;
analizzaDatiSlot = async function (allData) {
  await oldAnalizza10(allData);
  if (isMaster && ws && ws.readyState === 1) {
    inviaBroadcast({
      info: "Analisi aggiornata",
      analisi: analisiGlobale,
      alert: `Aggiornate ${analisiGlobale.length} slot dal server master`
    });
  }
};

/* Avvio della sincronizzazione */
function setupSyncRole() {
  const role = prompt("üëâ Inserisci ruolo dispositivo: 'master' o 'client'");
  if (role && role.toLowerCase() === "master") {
    isMaster = true;
    toast("üß≠ Questo dispositivo √® il MASTER (invier√† analisi)");
  } else {
    isMaster = false;
    toast("üì± Questo dispositivo √® CLIENT (ricever√† dati)");
  }
  avviaSyncSocket();
}

setupSyncRole();
</script>
</body>
</html>
